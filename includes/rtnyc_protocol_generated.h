// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RTNYCPROTOCOL_NYC_REALTIME_H_
#define FLATBUFFERS_GENERATED_RTNYCPROTOCOL_NYC_REALTIME_H_

#include "flatbuffers/flatbuffers.h"

namespace nyc {
namespace realtime {

struct _Version3;

struct ClientCommandProxyRequest;

struct ClientCommandProxyResponse;

struct Position;

struct NYCSubwayTrip;

struct NYCSubwaySchedule;

struct NYCSubwayVehiclePosition;

struct NYCBusTrip;

struct NYCBusSchedule;

struct NYCSubwayStopUpdate;

struct NYCSubwayScheduleUpdate;

struct NYCSubwayTrips;

struct NYCSubwayTripComplete;

struct NYCBusStopUpdate;

struct NYCBusScheduleUpdate;

struct NYCBusTrips;

struct NYCBusTripComplete;

enum TripStatus {
  TripStatus_AtStation = 0,
  TripStatus_ApproachingStation = 1,
  TripStatus_EnrouteToStation = 2,
  TripStatus_MIN = TripStatus_AtStation,
  TripStatus_MAX = TripStatus_EnrouteToStation
};

inline const TripStatus (&EnumValuesTripStatus())[3] {
  static const TripStatus values[] = {
    TripStatus_AtStation,
    TripStatus_ApproachingStation,
    TripStatus_EnrouteToStation
  };
  return values;
}

inline const char * const *EnumNamesTripStatus() {
  static const char * const names[] = {
    "AtStation",
    "ApproachingStation",
    "EnrouteToStation",
    nullptr
  };
  return names;
}

inline const char *EnumNameTripStatus(TripStatus e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTripStatus()[index];
}

enum Direction {
  Direction_North = 0,
  Direction_South = 1,
  Direction_East = 2,
  Direction_West = 3,
  Direction_MIN = Direction_North,
  Direction_MAX = Direction_West
};

inline const Direction (&EnumValuesDirection())[4] {
  static const Direction values[] = {
    Direction_North,
    Direction_South,
    Direction_East,
    Direction_West
  };
  return values;
}

inline const char * const *EnumNamesDirection() {
  static const char * const names[] = {
    "North",
    "South",
    "East",
    "West",
    nullptr
  };
  return names;
}

inline const char *EnumNameDirection(Direction e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDirection()[index];
}

struct _Version3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct _Version3Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit _Version3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  _Version3Builder &operator=(const _Version3Builder &);
  flatbuffers::Offset<_Version3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<_Version3>(end);
    return o;
  }
};

inline flatbuffers::Offset<_Version3> Create_Version3(
    flatbuffers::FlatBufferBuilder &_fbb) {
  _Version3Builder builder_(_fbb);
  return builder_.Finish();
}

struct ClientCommandProxyRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_USER_ADDRESS = 4,
    VT_REQUEST_ID = 6,
    VT_PAYLOAD = 8
  };
  int32_t user_address() const {
    return GetField<int32_t>(VT_USER_ADDRESS, 0);
  }
  int32_t request_id() const {
    return GetField<int32_t>(VT_REQUEST_ID, 0);
  }
  const flatbuffers::String *payload() const {
    return GetPointer<const flatbuffers::String *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_USER_ADDRESS) &&
           VerifyField<int32_t>(verifier, VT_REQUEST_ID) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.Verify(payload()) &&
           verifier.EndTable();
  }
};

struct ClientCommandProxyRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user_address(int32_t user_address) {
    fbb_.AddElement<int32_t>(ClientCommandProxyRequest::VT_USER_ADDRESS, user_address, 0);
  }
  void add_request_id(int32_t request_id) {
    fbb_.AddElement<int32_t>(ClientCommandProxyRequest::VT_REQUEST_ID, request_id, 0);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::String> payload) {
    fbb_.AddOffset(ClientCommandProxyRequest::VT_PAYLOAD, payload);
  }
  explicit ClientCommandProxyRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientCommandProxyRequestBuilder &operator=(const ClientCommandProxyRequestBuilder &);
  flatbuffers::Offset<ClientCommandProxyRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientCommandProxyRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientCommandProxyRequest> CreateClientCommandProxyRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t user_address = 0,
    int32_t request_id = 0,
    flatbuffers::Offset<flatbuffers::String> payload = 0) {
  ClientCommandProxyRequestBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_request_id(request_id);
  builder_.add_user_address(user_address);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClientCommandProxyRequest> CreateClientCommandProxyRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t user_address = 0,
    int32_t request_id = 0,
    const char *payload = nullptr) {
  return nyc::realtime::CreateClientCommandProxyRequest(
      _fbb,
      user_address,
      request_id,
      payload ? _fbb.CreateString(payload) : 0);
}

struct ClientCommandProxyResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REQUEST_ID = 4,
    VT_FORMAT = 6,
    VT_PAYLOAD = 8
  };
  int32_t request_id() const {
    return GetField<int32_t>(VT_REQUEST_ID, 0);
  }
  int8_t format() const {
    return GetField<int8_t>(VT_FORMAT, 0);
  }
  const flatbuffers::String *payload() const {
    return GetPointer<const flatbuffers::String *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REQUEST_ID) &&
           VerifyField<int8_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.Verify(payload()) &&
           verifier.EndTable();
  }
};

struct ClientCommandProxyResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_request_id(int32_t request_id) {
    fbb_.AddElement<int32_t>(ClientCommandProxyResponse::VT_REQUEST_ID, request_id, 0);
  }
  void add_format(int8_t format) {
    fbb_.AddElement<int8_t>(ClientCommandProxyResponse::VT_FORMAT, format, 0);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::String> payload) {
    fbb_.AddOffset(ClientCommandProxyResponse::VT_PAYLOAD, payload);
  }
  explicit ClientCommandProxyResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClientCommandProxyResponseBuilder &operator=(const ClientCommandProxyResponseBuilder &);
  flatbuffers::Offset<ClientCommandProxyResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClientCommandProxyResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClientCommandProxyResponse> CreateClientCommandProxyResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t request_id = 0,
    int8_t format = 0,
    flatbuffers::Offset<flatbuffers::String> payload = 0) {
  ClientCommandProxyResponseBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_request_id(request_id);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<ClientCommandProxyResponse> CreateClientCommandProxyResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t request_id = 0,
    int8_t format = 0,
    const char *payload = nullptr) {
  return nyc::realtime::CreateClientCommandProxyResponse(
      _fbb,
      request_id,
      format,
      payload ? _fbb.CreateString(payload) : 0);
}

struct Position FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LATITUDE = 4,
    VT_LONGITUDE = 6,
    VT_BEARING = 8
  };
  float latitude() const {
    return GetField<float>(VT_LATITUDE, 0.0f);
  }
  float longitude() const {
    return GetField<float>(VT_LONGITUDE, 0.0f);
  }
  float bearing() const {
    return GetField<float>(VT_BEARING, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LATITUDE) &&
           VerifyField<float>(verifier, VT_LONGITUDE) &&
           VerifyField<float>(verifier, VT_BEARING) &&
           verifier.EndTable();
  }
};

struct PositionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_latitude(float latitude) {
    fbb_.AddElement<float>(Position::VT_LATITUDE, latitude, 0.0f);
  }
  void add_longitude(float longitude) {
    fbb_.AddElement<float>(Position::VT_LONGITUDE, longitude, 0.0f);
  }
  void add_bearing(float bearing) {
    fbb_.AddElement<float>(Position::VT_BEARING, bearing, 0.0f);
  }
  explicit PositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PositionBuilder &operator=(const PositionBuilder &);
  flatbuffers::Offset<Position> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Position>(end);
    return o;
  }
};

inline flatbuffers::Offset<Position> CreatePosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    float latitude = 0.0f,
    float longitude = 0.0f,
    float bearing = 0.0f) {
  PositionBuilder builder_(_fbb);
  builder_.add_bearing(bearing);
  builder_.add_longitude(longitude);
  builder_.add_latitude(latitude);
  return builder_.Finish();
}

struct NYCSubwayTrip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GTFS_TRIP_ID = 4,
    VT_TRIP_ID = 6,
    VT_START_TIME = 8,
    VT_ROUTE_ID = 10,
    VT_ASSIGNED = 12,
    VT_DIRECTION = 14
  };
  const flatbuffers::String *gtfs_trip_id() const {
    return GetPointer<const flatbuffers::String *>(VT_GTFS_TRIP_ID);
  }
  const flatbuffers::String *trip_id() const {
    return GetPointer<const flatbuffers::String *>(VT_TRIP_ID);
  }
  int32_t start_time() const {
    return GetField<int32_t>(VT_START_TIME, 0);
  }
  const flatbuffers::String *route_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTE_ID);
  }
  bool assigned() const {
    return GetField<uint8_t>(VT_ASSIGNED, 0) != 0;
  }
  Direction direction() const {
    return static_cast<Direction>(GetField<int8_t>(VT_DIRECTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GTFS_TRIP_ID) &&
           verifier.Verify(gtfs_trip_id()) &&
           VerifyOffset(verifier, VT_TRIP_ID) &&
           verifier.Verify(trip_id()) &&
           VerifyField<int32_t>(verifier, VT_START_TIME) &&
           VerifyOffset(verifier, VT_ROUTE_ID) &&
           verifier.Verify(route_id()) &&
           VerifyField<uint8_t>(verifier, VT_ASSIGNED) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION) &&
           verifier.EndTable();
  }
};

struct NYCSubwayTripBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gtfs_trip_id(flatbuffers::Offset<flatbuffers::String> gtfs_trip_id) {
    fbb_.AddOffset(NYCSubwayTrip::VT_GTFS_TRIP_ID, gtfs_trip_id);
  }
  void add_trip_id(flatbuffers::Offset<flatbuffers::String> trip_id) {
    fbb_.AddOffset(NYCSubwayTrip::VT_TRIP_ID, trip_id);
  }
  void add_start_time(int32_t start_time) {
    fbb_.AddElement<int32_t>(NYCSubwayTrip::VT_START_TIME, start_time, 0);
  }
  void add_route_id(flatbuffers::Offset<flatbuffers::String> route_id) {
    fbb_.AddOffset(NYCSubwayTrip::VT_ROUTE_ID, route_id);
  }
  void add_assigned(bool assigned) {
    fbb_.AddElement<uint8_t>(NYCSubwayTrip::VT_ASSIGNED, static_cast<uint8_t>(assigned), 0);
  }
  void add_direction(Direction direction) {
    fbb_.AddElement<int8_t>(NYCSubwayTrip::VT_DIRECTION, static_cast<int8_t>(direction), 0);
  }
  explicit NYCSubwayTripBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NYCSubwayTripBuilder &operator=(const NYCSubwayTripBuilder &);
  flatbuffers::Offset<NYCSubwayTrip> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NYCSubwayTrip>(end);
    return o;
  }
};

inline flatbuffers::Offset<NYCSubwayTrip> CreateNYCSubwayTrip(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> gtfs_trip_id = 0,
    flatbuffers::Offset<flatbuffers::String> trip_id = 0,
    int32_t start_time = 0,
    flatbuffers::Offset<flatbuffers::String> route_id = 0,
    bool assigned = false,
    Direction direction = Direction_North) {
  NYCSubwayTripBuilder builder_(_fbb);
  builder_.add_route_id(route_id);
  builder_.add_start_time(start_time);
  builder_.add_trip_id(trip_id);
  builder_.add_gtfs_trip_id(gtfs_trip_id);
  builder_.add_direction(direction);
  builder_.add_assigned(assigned);
  return builder_.Finish();
}

inline flatbuffers::Offset<NYCSubwayTrip> CreateNYCSubwayTripDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *gtfs_trip_id = nullptr,
    const char *trip_id = nullptr,
    int32_t start_time = 0,
    const char *route_id = nullptr,
    bool assigned = false,
    Direction direction = Direction_North) {
  return nyc::realtime::CreateNYCSubwayTrip(
      _fbb,
      gtfs_trip_id ? _fbb.CreateString(gtfs_trip_id) : 0,
      trip_id ? _fbb.CreateString(trip_id) : 0,
      start_time,
      route_id ? _fbb.CreateString(route_id) : 0,
      assigned,
      direction);
}

struct NYCSubwaySchedule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SCHEDULED_TRACK = 4,
    VT_ACTUAL_TRACK = 6,
    VT_ARRIVAL_TIME = 8,
    VT_DEPARTURE_TIME = 10,
    VT_STOP_ID = 12
  };
  const flatbuffers::String *scheduled_track() const {
    return GetPointer<const flatbuffers::String *>(VT_SCHEDULED_TRACK);
  }
  const flatbuffers::String *actual_track() const {
    return GetPointer<const flatbuffers::String *>(VT_ACTUAL_TRACK);
  }
  int32_t arrival_time() const {
    return GetField<int32_t>(VT_ARRIVAL_TIME, 0);
  }
  int32_t departure_time() const {
    return GetField<int32_t>(VT_DEPARTURE_TIME, 0);
  }
  const flatbuffers::String *stop_id() const {
    return GetPointer<const flatbuffers::String *>(VT_STOP_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SCHEDULED_TRACK) &&
           verifier.Verify(scheduled_track()) &&
           VerifyOffset(verifier, VT_ACTUAL_TRACK) &&
           verifier.Verify(actual_track()) &&
           VerifyField<int32_t>(verifier, VT_ARRIVAL_TIME) &&
           VerifyField<int32_t>(verifier, VT_DEPARTURE_TIME) &&
           VerifyOffset(verifier, VT_STOP_ID) &&
           verifier.Verify(stop_id()) &&
           verifier.EndTable();
  }
};

struct NYCSubwayScheduleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scheduled_track(flatbuffers::Offset<flatbuffers::String> scheduled_track) {
    fbb_.AddOffset(NYCSubwaySchedule::VT_SCHEDULED_TRACK, scheduled_track);
  }
  void add_actual_track(flatbuffers::Offset<flatbuffers::String> actual_track) {
    fbb_.AddOffset(NYCSubwaySchedule::VT_ACTUAL_TRACK, actual_track);
  }
  void add_arrival_time(int32_t arrival_time) {
    fbb_.AddElement<int32_t>(NYCSubwaySchedule::VT_ARRIVAL_TIME, arrival_time, 0);
  }
  void add_departure_time(int32_t departure_time) {
    fbb_.AddElement<int32_t>(NYCSubwaySchedule::VT_DEPARTURE_TIME, departure_time, 0);
  }
  void add_stop_id(flatbuffers::Offset<flatbuffers::String> stop_id) {
    fbb_.AddOffset(NYCSubwaySchedule::VT_STOP_ID, stop_id);
  }
  explicit NYCSubwayScheduleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NYCSubwayScheduleBuilder &operator=(const NYCSubwayScheduleBuilder &);
  flatbuffers::Offset<NYCSubwaySchedule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NYCSubwaySchedule>(end);
    return o;
  }
};

inline flatbuffers::Offset<NYCSubwaySchedule> CreateNYCSubwaySchedule(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> scheduled_track = 0,
    flatbuffers::Offset<flatbuffers::String> actual_track = 0,
    int32_t arrival_time = 0,
    int32_t departure_time = 0,
    flatbuffers::Offset<flatbuffers::String> stop_id = 0) {
  NYCSubwayScheduleBuilder builder_(_fbb);
  builder_.add_stop_id(stop_id);
  builder_.add_departure_time(departure_time);
  builder_.add_arrival_time(arrival_time);
  builder_.add_actual_track(actual_track);
  builder_.add_scheduled_track(scheduled_track);
  return builder_.Finish();
}

inline flatbuffers::Offset<NYCSubwaySchedule> CreateNYCSubwayScheduleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *scheduled_track = nullptr,
    const char *actual_track = nullptr,
    int32_t arrival_time = 0,
    int32_t departure_time = 0,
    const char *stop_id = nullptr) {
  return nyc::realtime::CreateNYCSubwaySchedule(
      _fbb,
      scheduled_track ? _fbb.CreateString(scheduled_track) : 0,
      actual_track ? _fbb.CreateString(actual_track) : 0,
      arrival_time,
      departure_time,
      stop_id ? _fbb.CreateString(stop_id) : 0);
}

struct NYCSubwayVehiclePosition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STOP_ID = 4,
    VT_TRACK = 6,
    VT_RELATIVE_STATUS = 8,
    VT_STOP_INDEX = 10
  };
  const flatbuffers::String *stop_id() const {
    return GetPointer<const flatbuffers::String *>(VT_STOP_ID);
  }
  const flatbuffers::String *track() const {
    return GetPointer<const flatbuffers::String *>(VT_TRACK);
  }
  TripStatus relative_status() const {
    return static_cast<TripStatus>(GetField<int8_t>(VT_RELATIVE_STATUS, 0));
  }
  int32_t stop_index() const {
    return GetField<int32_t>(VT_STOP_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STOP_ID) &&
           verifier.Verify(stop_id()) &&
           VerifyOffset(verifier, VT_TRACK) &&
           verifier.Verify(track()) &&
           VerifyField<int8_t>(verifier, VT_RELATIVE_STATUS) &&
           VerifyField<int32_t>(verifier, VT_STOP_INDEX) &&
           verifier.EndTable();
  }
};

struct NYCSubwayVehiclePositionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stop_id(flatbuffers::Offset<flatbuffers::String> stop_id) {
    fbb_.AddOffset(NYCSubwayVehiclePosition::VT_STOP_ID, stop_id);
  }
  void add_track(flatbuffers::Offset<flatbuffers::String> track) {
    fbb_.AddOffset(NYCSubwayVehiclePosition::VT_TRACK, track);
  }
  void add_relative_status(TripStatus relative_status) {
    fbb_.AddElement<int8_t>(NYCSubwayVehiclePosition::VT_RELATIVE_STATUS, static_cast<int8_t>(relative_status), 0);
  }
  void add_stop_index(int32_t stop_index) {
    fbb_.AddElement<int32_t>(NYCSubwayVehiclePosition::VT_STOP_INDEX, stop_index, 0);
  }
  explicit NYCSubwayVehiclePositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NYCSubwayVehiclePositionBuilder &operator=(const NYCSubwayVehiclePositionBuilder &);
  flatbuffers::Offset<NYCSubwayVehiclePosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NYCSubwayVehiclePosition>(end);
    return o;
  }
};

inline flatbuffers::Offset<NYCSubwayVehiclePosition> CreateNYCSubwayVehiclePosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> stop_id = 0,
    flatbuffers::Offset<flatbuffers::String> track = 0,
    TripStatus relative_status = TripStatus_AtStation,
    int32_t stop_index = 0) {
  NYCSubwayVehiclePositionBuilder builder_(_fbb);
  builder_.add_stop_index(stop_index);
  builder_.add_track(track);
  builder_.add_stop_id(stop_id);
  builder_.add_relative_status(relative_status);
  return builder_.Finish();
}

inline flatbuffers::Offset<NYCSubwayVehiclePosition> CreateNYCSubwayVehiclePositionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *stop_id = nullptr,
    const char *track = nullptr,
    TripStatus relative_status = TripStatus_AtStation,
    int32_t stop_index = 0) {
  return nyc::realtime::CreateNYCSubwayVehiclePosition(
      _fbb,
      stop_id ? _fbb.CreateString(stop_id) : 0,
      track ? _fbb.CreateString(track) : 0,
      relative_status,
      stop_index);
}

struct NYCBusTrip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GTFS_TRIP_ID = 4,
    VT_ROUTE_ID = 6,
    VT_START_DATE = 8,
    VT_VEHICLE_ID = 10
  };
  const flatbuffers::String *gtfs_trip_id() const {
    return GetPointer<const flatbuffers::String *>(VT_GTFS_TRIP_ID);
  }
  const flatbuffers::String *route_id() const {
    return GetPointer<const flatbuffers::String *>(VT_ROUTE_ID);
  }
  const flatbuffers::String *start_date() const {
    return GetPointer<const flatbuffers::String *>(VT_START_DATE);
  }
  const flatbuffers::String *vehicle_id() const {
    return GetPointer<const flatbuffers::String *>(VT_VEHICLE_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GTFS_TRIP_ID) &&
           verifier.Verify(gtfs_trip_id()) &&
           VerifyOffset(verifier, VT_ROUTE_ID) &&
           verifier.Verify(route_id()) &&
           VerifyOffset(verifier, VT_START_DATE) &&
           verifier.Verify(start_date()) &&
           VerifyOffset(verifier, VT_VEHICLE_ID) &&
           verifier.Verify(vehicle_id()) &&
           verifier.EndTable();
  }
};

struct NYCBusTripBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gtfs_trip_id(flatbuffers::Offset<flatbuffers::String> gtfs_trip_id) {
    fbb_.AddOffset(NYCBusTrip::VT_GTFS_TRIP_ID, gtfs_trip_id);
  }
  void add_route_id(flatbuffers::Offset<flatbuffers::String> route_id) {
    fbb_.AddOffset(NYCBusTrip::VT_ROUTE_ID, route_id);
  }
  void add_start_date(flatbuffers::Offset<flatbuffers::String> start_date) {
    fbb_.AddOffset(NYCBusTrip::VT_START_DATE, start_date);
  }
  void add_vehicle_id(flatbuffers::Offset<flatbuffers::String> vehicle_id) {
    fbb_.AddOffset(NYCBusTrip::VT_VEHICLE_ID, vehicle_id);
  }
  explicit NYCBusTripBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NYCBusTripBuilder &operator=(const NYCBusTripBuilder &);
  flatbuffers::Offset<NYCBusTrip> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NYCBusTrip>(end);
    return o;
  }
};

inline flatbuffers::Offset<NYCBusTrip> CreateNYCBusTrip(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> gtfs_trip_id = 0,
    flatbuffers::Offset<flatbuffers::String> route_id = 0,
    flatbuffers::Offset<flatbuffers::String> start_date = 0,
    flatbuffers::Offset<flatbuffers::String> vehicle_id = 0) {
  NYCBusTripBuilder builder_(_fbb);
  builder_.add_vehicle_id(vehicle_id);
  builder_.add_start_date(start_date);
  builder_.add_route_id(route_id);
  builder_.add_gtfs_trip_id(gtfs_trip_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<NYCBusTrip> CreateNYCBusTripDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *gtfs_trip_id = nullptr,
    const char *route_id = nullptr,
    const char *start_date = nullptr,
    const char *vehicle_id = nullptr) {
  return nyc::realtime::CreateNYCBusTrip(
      _fbb,
      gtfs_trip_id ? _fbb.CreateString(gtfs_trip_id) : 0,
      route_id ? _fbb.CreateString(route_id) : 0,
      start_date ? _fbb.CreateString(start_date) : 0,
      vehicle_id ? _fbb.CreateString(vehicle_id) : 0);
}

struct NYCBusSchedule FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ARRIVAL_TIME = 4,
    VT_DEPARTURE_TIME = 6,
    VT_STOP_ID = 8
  };
  int32_t arrival_time() const {
    return GetField<int32_t>(VT_ARRIVAL_TIME, 0);
  }
  int32_t departure_time() const {
    return GetField<int32_t>(VT_DEPARTURE_TIME, 0);
  }
  const flatbuffers::String *stop_id() const {
    return GetPointer<const flatbuffers::String *>(VT_STOP_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ARRIVAL_TIME) &&
           VerifyField<int32_t>(verifier, VT_DEPARTURE_TIME) &&
           VerifyOffset(verifier, VT_STOP_ID) &&
           verifier.Verify(stop_id()) &&
           verifier.EndTable();
  }
};

struct NYCBusScheduleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_arrival_time(int32_t arrival_time) {
    fbb_.AddElement<int32_t>(NYCBusSchedule::VT_ARRIVAL_TIME, arrival_time, 0);
  }
  void add_departure_time(int32_t departure_time) {
    fbb_.AddElement<int32_t>(NYCBusSchedule::VT_DEPARTURE_TIME, departure_time, 0);
  }
  void add_stop_id(flatbuffers::Offset<flatbuffers::String> stop_id) {
    fbb_.AddOffset(NYCBusSchedule::VT_STOP_ID, stop_id);
  }
  explicit NYCBusScheduleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NYCBusScheduleBuilder &operator=(const NYCBusScheduleBuilder &);
  flatbuffers::Offset<NYCBusSchedule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NYCBusSchedule>(end);
    return o;
  }
};

inline flatbuffers::Offset<NYCBusSchedule> CreateNYCBusSchedule(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t arrival_time = 0,
    int32_t departure_time = 0,
    flatbuffers::Offset<flatbuffers::String> stop_id = 0) {
  NYCBusScheduleBuilder builder_(_fbb);
  builder_.add_stop_id(stop_id);
  builder_.add_departure_time(departure_time);
  builder_.add_arrival_time(arrival_time);
  return builder_.Finish();
}

inline flatbuffers::Offset<NYCBusSchedule> CreateNYCBusScheduleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t arrival_time = 0,
    int32_t departure_time = 0,
    const char *stop_id = nullptr) {
  return nyc::realtime::CreateNYCBusSchedule(
      _fbb,
      arrival_time,
      departure_time,
      stop_id ? _fbb.CreateString(stop_id) : 0);
}

struct NYCSubwayStopUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_TRIP_ID = 6,
    VT_CURRENT_STATUS = 8,
    VT_CUMULATIVE_ARRIVAL_DELAY = 10,
    VT_CUMULATIVE_DEPARTURE_DELAY = 12,
    VT_ON_SCHEDULE = 14,
    VT_CURRENT_STOP_ID = 16,
    VT_CURRENT_STOP_DEPARTING_ON = 18,
    VT_NEXT_STOP_ID = 20,
    VT_NEXT_STOP_ARRIVING_ON = 22,
    VT_NEXT_STOP_DEPARTING_ON = 24,
    VT_LAST_STOP_ID = 26
  };
  int32_t timestamp() const {
    return GetField<int32_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::String *trip_id() const {
    return GetPointer<const flatbuffers::String *>(VT_TRIP_ID);
  }
  TripStatus current_status() const {
    return static_cast<TripStatus>(GetField<int8_t>(VT_CURRENT_STATUS, 0));
  }
  int32_t cumulative_arrival_delay() const {
    return GetField<int32_t>(VT_CUMULATIVE_ARRIVAL_DELAY, 0);
  }
  int32_t cumulative_departure_delay() const {
    return GetField<int32_t>(VT_CUMULATIVE_DEPARTURE_DELAY, 0);
  }
  bool on_schedule() const {
    return GetField<uint8_t>(VT_ON_SCHEDULE, 0) != 0;
  }
  const flatbuffers::String *current_stop_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CURRENT_STOP_ID);
  }
  int32_t current_stop_departing_on() const {
    return GetField<int32_t>(VT_CURRENT_STOP_DEPARTING_ON, 0);
  }
  const flatbuffers::String *next_stop_id() const {
    return GetPointer<const flatbuffers::String *>(VT_NEXT_STOP_ID);
  }
  int32_t next_stop_arriving_on() const {
    return GetField<int32_t>(VT_NEXT_STOP_ARRIVING_ON, 0);
  }
  int32_t next_stop_departing_on() const {
    return GetField<int32_t>(VT_NEXT_STOP_DEPARTING_ON, 0);
  }
  const flatbuffers::String *last_stop_id() const {
    return GetPointer<const flatbuffers::String *>(VT_LAST_STOP_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_TRIP_ID) &&
           verifier.Verify(trip_id()) &&
           VerifyField<int8_t>(verifier, VT_CURRENT_STATUS) &&
           VerifyField<int32_t>(verifier, VT_CUMULATIVE_ARRIVAL_DELAY) &&
           VerifyField<int32_t>(verifier, VT_CUMULATIVE_DEPARTURE_DELAY) &&
           VerifyField<uint8_t>(verifier, VT_ON_SCHEDULE) &&
           VerifyOffset(verifier, VT_CURRENT_STOP_ID) &&
           verifier.Verify(current_stop_id()) &&
           VerifyField<int32_t>(verifier, VT_CURRENT_STOP_DEPARTING_ON) &&
           VerifyOffset(verifier, VT_NEXT_STOP_ID) &&
           verifier.Verify(next_stop_id()) &&
           VerifyField<int32_t>(verifier, VT_NEXT_STOP_ARRIVING_ON) &&
           VerifyField<int32_t>(verifier, VT_NEXT_STOP_DEPARTING_ON) &&
           VerifyOffset(verifier, VT_LAST_STOP_ID) &&
           verifier.Verify(last_stop_id()) &&
           verifier.EndTable();
  }
};

struct NYCSubwayStopUpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int32_t timestamp) {
    fbb_.AddElement<int32_t>(NYCSubwayStopUpdate::VT_TIMESTAMP, timestamp, 0);
  }
  void add_trip_id(flatbuffers::Offset<flatbuffers::String> trip_id) {
    fbb_.AddOffset(NYCSubwayStopUpdate::VT_TRIP_ID, trip_id);
  }
  void add_current_status(TripStatus current_status) {
    fbb_.AddElement<int8_t>(NYCSubwayStopUpdate::VT_CURRENT_STATUS, static_cast<int8_t>(current_status), 0);
  }
  void add_cumulative_arrival_delay(int32_t cumulative_arrival_delay) {
    fbb_.AddElement<int32_t>(NYCSubwayStopUpdate::VT_CUMULATIVE_ARRIVAL_DELAY, cumulative_arrival_delay, 0);
  }
  void add_cumulative_departure_delay(int32_t cumulative_departure_delay) {
    fbb_.AddElement<int32_t>(NYCSubwayStopUpdate::VT_CUMULATIVE_DEPARTURE_DELAY, cumulative_departure_delay, 0);
  }
  void add_on_schedule(bool on_schedule) {
    fbb_.AddElement<uint8_t>(NYCSubwayStopUpdate::VT_ON_SCHEDULE, static_cast<uint8_t>(on_schedule), 0);
  }
  void add_current_stop_id(flatbuffers::Offset<flatbuffers::String> current_stop_id) {
    fbb_.AddOffset(NYCSubwayStopUpdate::VT_CURRENT_STOP_ID, current_stop_id);
  }
  void add_current_stop_departing_on(int32_t current_stop_departing_on) {
    fbb_.AddElement<int32_t>(NYCSubwayStopUpdate::VT_CURRENT_STOP_DEPARTING_ON, current_stop_departing_on, 0);
  }
  void add_next_stop_id(flatbuffers::Offset<flatbuffers::String> next_stop_id) {
    fbb_.AddOffset(NYCSubwayStopUpdate::VT_NEXT_STOP_ID, next_stop_id);
  }
  void add_next_stop_arriving_on(int32_t next_stop_arriving_on) {
    fbb_.AddElement<int32_t>(NYCSubwayStopUpdate::VT_NEXT_STOP_ARRIVING_ON, next_stop_arriving_on, 0);
  }
  void add_next_stop_departing_on(int32_t next_stop_departing_on) {
    fbb_.AddElement<int32_t>(NYCSubwayStopUpdate::VT_NEXT_STOP_DEPARTING_ON, next_stop_departing_on, 0);
  }
  void add_last_stop_id(flatbuffers::Offset<flatbuffers::String> last_stop_id) {
    fbb_.AddOffset(NYCSubwayStopUpdate::VT_LAST_STOP_ID, last_stop_id);
  }
  explicit NYCSubwayStopUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NYCSubwayStopUpdateBuilder &operator=(const NYCSubwayStopUpdateBuilder &);
  flatbuffers::Offset<NYCSubwayStopUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NYCSubwayStopUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<NYCSubwayStopUpdate> CreateNYCSubwayStopUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> trip_id = 0,
    TripStatus current_status = TripStatus_AtStation,
    int32_t cumulative_arrival_delay = 0,
    int32_t cumulative_departure_delay = 0,
    bool on_schedule = false,
    flatbuffers::Offset<flatbuffers::String> current_stop_id = 0,
    int32_t current_stop_departing_on = 0,
    flatbuffers::Offset<flatbuffers::String> next_stop_id = 0,
    int32_t next_stop_arriving_on = 0,
    int32_t next_stop_departing_on = 0,
    flatbuffers::Offset<flatbuffers::String> last_stop_id = 0) {
  NYCSubwayStopUpdateBuilder builder_(_fbb);
  builder_.add_last_stop_id(last_stop_id);
  builder_.add_next_stop_departing_on(next_stop_departing_on);
  builder_.add_next_stop_arriving_on(next_stop_arriving_on);
  builder_.add_next_stop_id(next_stop_id);
  builder_.add_current_stop_departing_on(current_stop_departing_on);
  builder_.add_current_stop_id(current_stop_id);
  builder_.add_cumulative_departure_delay(cumulative_departure_delay);
  builder_.add_cumulative_arrival_delay(cumulative_arrival_delay);
  builder_.add_trip_id(trip_id);
  builder_.add_timestamp(timestamp);
  builder_.add_on_schedule(on_schedule);
  builder_.add_current_status(current_status);
  return builder_.Finish();
}

inline flatbuffers::Offset<NYCSubwayStopUpdate> CreateNYCSubwayStopUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    const char *trip_id = nullptr,
    TripStatus current_status = TripStatus_AtStation,
    int32_t cumulative_arrival_delay = 0,
    int32_t cumulative_departure_delay = 0,
    bool on_schedule = false,
    const char *current_stop_id = nullptr,
    int32_t current_stop_departing_on = 0,
    const char *next_stop_id = nullptr,
    int32_t next_stop_arriving_on = 0,
    int32_t next_stop_departing_on = 0,
    const char *last_stop_id = nullptr) {
  return nyc::realtime::CreateNYCSubwayStopUpdate(
      _fbb,
      timestamp,
      trip_id ? _fbb.CreateString(trip_id) : 0,
      current_status,
      cumulative_arrival_delay,
      cumulative_departure_delay,
      on_schedule,
      current_stop_id ? _fbb.CreateString(current_stop_id) : 0,
      current_stop_departing_on,
      next_stop_id ? _fbb.CreateString(next_stop_id) : 0,
      next_stop_arriving_on,
      next_stop_departing_on,
      last_stop_id ? _fbb.CreateString(last_stop_id) : 0);
}

struct NYCSubwayScheduleUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_TRIP = 6,
    VT_SCHEDULE = 8,
    VT_LAST_VEHICLE_POSITION = 10
  };
  int32_t timestamp() const {
    return GetField<int32_t>(VT_TIMESTAMP, 0);
  }
  const NYCSubwayTrip *trip() const {
    return GetPointer<const NYCSubwayTrip *>(VT_TRIP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NYCSubwaySchedule>> *schedule() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NYCSubwaySchedule>> *>(VT_SCHEDULE);
  }
  const NYCSubwayVehiclePosition *last_vehicle_position() const {
    return GetPointer<const NYCSubwayVehiclePosition *>(VT_LAST_VEHICLE_POSITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_TRIP) &&
           verifier.VerifyTable(trip()) &&
           VerifyOffset(verifier, VT_SCHEDULE) &&
           verifier.Verify(schedule()) &&
           verifier.VerifyVectorOfTables(schedule()) &&
           VerifyOffset(verifier, VT_LAST_VEHICLE_POSITION) &&
           verifier.VerifyTable(last_vehicle_position()) &&
           verifier.EndTable();
  }
};

struct NYCSubwayScheduleUpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int32_t timestamp) {
    fbb_.AddElement<int32_t>(NYCSubwayScheduleUpdate::VT_TIMESTAMP, timestamp, 0);
  }
  void add_trip(flatbuffers::Offset<NYCSubwayTrip> trip) {
    fbb_.AddOffset(NYCSubwayScheduleUpdate::VT_TRIP, trip);
  }
  void add_schedule(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NYCSubwaySchedule>>> schedule) {
    fbb_.AddOffset(NYCSubwayScheduleUpdate::VT_SCHEDULE, schedule);
  }
  void add_last_vehicle_position(flatbuffers::Offset<NYCSubwayVehiclePosition> last_vehicle_position) {
    fbb_.AddOffset(NYCSubwayScheduleUpdate::VT_LAST_VEHICLE_POSITION, last_vehicle_position);
  }
  explicit NYCSubwayScheduleUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NYCSubwayScheduleUpdateBuilder &operator=(const NYCSubwayScheduleUpdateBuilder &);
  flatbuffers::Offset<NYCSubwayScheduleUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NYCSubwayScheduleUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<NYCSubwayScheduleUpdate> CreateNYCSubwayScheduleUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    flatbuffers::Offset<NYCSubwayTrip> trip = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NYCSubwaySchedule>>> schedule = 0,
    flatbuffers::Offset<NYCSubwayVehiclePosition> last_vehicle_position = 0) {
  NYCSubwayScheduleUpdateBuilder builder_(_fbb);
  builder_.add_last_vehicle_position(last_vehicle_position);
  builder_.add_schedule(schedule);
  builder_.add_trip(trip);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<NYCSubwayScheduleUpdate> CreateNYCSubwayScheduleUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    flatbuffers::Offset<NYCSubwayTrip> trip = 0,
    const std::vector<flatbuffers::Offset<NYCSubwaySchedule>> *schedule = nullptr,
    flatbuffers::Offset<NYCSubwayVehiclePosition> last_vehicle_position = 0) {
  return nyc::realtime::CreateNYCSubwayScheduleUpdate(
      _fbb,
      timestamp,
      trip,
      schedule ? _fbb.CreateVector<flatbuffers::Offset<NYCSubwaySchedule>>(*schedule) : 0,
      last_vehicle_position);
}

struct NYCSubwayTrips FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_TRIPS = 6
  };
  int32_t timestamp() const {
    return GetField<int32_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NYCSubwayScheduleUpdate>> *trips() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NYCSubwayScheduleUpdate>> *>(VT_TRIPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_TRIPS) &&
           verifier.Verify(trips()) &&
           verifier.VerifyVectorOfTables(trips()) &&
           verifier.EndTable();
  }
};

struct NYCSubwayTripsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int32_t timestamp) {
    fbb_.AddElement<int32_t>(NYCSubwayTrips::VT_TIMESTAMP, timestamp, 0);
  }
  void add_trips(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NYCSubwayScheduleUpdate>>> trips) {
    fbb_.AddOffset(NYCSubwayTrips::VT_TRIPS, trips);
  }
  explicit NYCSubwayTripsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NYCSubwayTripsBuilder &operator=(const NYCSubwayTripsBuilder &);
  flatbuffers::Offset<NYCSubwayTrips> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NYCSubwayTrips>(end);
    return o;
  }
};

inline flatbuffers::Offset<NYCSubwayTrips> CreateNYCSubwayTrips(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NYCSubwayScheduleUpdate>>> trips = 0) {
  NYCSubwayTripsBuilder builder_(_fbb);
  builder_.add_trips(trips);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<NYCSubwayTrips> CreateNYCSubwayTripsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    const std::vector<flatbuffers::Offset<NYCSubwayScheduleUpdate>> *trips = nullptr) {
  return nyc::realtime::CreateNYCSubwayTrips(
      _fbb,
      timestamp,
      trips ? _fbb.CreateVector<flatbuffers::Offset<NYCSubwayScheduleUpdate>>(*trips) : 0);
}

struct NYCSubwayTripComplete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_TRIP_ID = 6
  };
  int32_t timestamp() const {
    return GetField<int32_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::String *trip_id() const {
    return GetPointer<const flatbuffers::String *>(VT_TRIP_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_TRIP_ID) &&
           verifier.Verify(trip_id()) &&
           verifier.EndTable();
  }
};

struct NYCSubwayTripCompleteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int32_t timestamp) {
    fbb_.AddElement<int32_t>(NYCSubwayTripComplete::VT_TIMESTAMP, timestamp, 0);
  }
  void add_trip_id(flatbuffers::Offset<flatbuffers::String> trip_id) {
    fbb_.AddOffset(NYCSubwayTripComplete::VT_TRIP_ID, trip_id);
  }
  explicit NYCSubwayTripCompleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NYCSubwayTripCompleteBuilder &operator=(const NYCSubwayTripCompleteBuilder &);
  flatbuffers::Offset<NYCSubwayTripComplete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NYCSubwayTripComplete>(end);
    return o;
  }
};

inline flatbuffers::Offset<NYCSubwayTripComplete> CreateNYCSubwayTripComplete(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> trip_id = 0) {
  NYCSubwayTripCompleteBuilder builder_(_fbb);
  builder_.add_trip_id(trip_id);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<NYCSubwayTripComplete> CreateNYCSubwayTripCompleteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    const char *trip_id = nullptr) {
  return nyc::realtime::CreateNYCSubwayTripComplete(
      _fbb,
      timestamp,
      trip_id ? _fbb.CreateString(trip_id) : 0);
}

struct NYCBusStopUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_TRIP = 6,
    VT_CURRENT_STATUS = 8,
    VT_STOP_ID = 10,
    VT_STOP_DEPARTING_ON = 12,
    VT_POSITION = 14,
    VT_DELAY = 16
  };
  int32_t timestamp() const {
    return GetField<int32_t>(VT_TIMESTAMP, 0);
  }
  const NYCBusTrip *trip() const {
    return GetPointer<const NYCBusTrip *>(VT_TRIP);
  }
  TripStatus current_status() const {
    return static_cast<TripStatus>(GetField<int8_t>(VT_CURRENT_STATUS, 0));
  }
  const flatbuffers::String *stop_id() const {
    return GetPointer<const flatbuffers::String *>(VT_STOP_ID);
  }
  int32_t stop_departing_on() const {
    return GetField<int32_t>(VT_STOP_DEPARTING_ON, 0);
  }
  const Position *position() const {
    return GetPointer<const Position *>(VT_POSITION);
  }
  int32_t delay() const {
    return GetField<int32_t>(VT_DELAY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_TRIP) &&
           verifier.VerifyTable(trip()) &&
           VerifyField<int8_t>(verifier, VT_CURRENT_STATUS) &&
           VerifyOffset(verifier, VT_STOP_ID) &&
           verifier.Verify(stop_id()) &&
           VerifyField<int32_t>(verifier, VT_STOP_DEPARTING_ON) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyField<int32_t>(verifier, VT_DELAY) &&
           verifier.EndTable();
  }
};

struct NYCBusStopUpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int32_t timestamp) {
    fbb_.AddElement<int32_t>(NYCBusStopUpdate::VT_TIMESTAMP, timestamp, 0);
  }
  void add_trip(flatbuffers::Offset<NYCBusTrip> trip) {
    fbb_.AddOffset(NYCBusStopUpdate::VT_TRIP, trip);
  }
  void add_current_status(TripStatus current_status) {
    fbb_.AddElement<int8_t>(NYCBusStopUpdate::VT_CURRENT_STATUS, static_cast<int8_t>(current_status), 0);
  }
  void add_stop_id(flatbuffers::Offset<flatbuffers::String> stop_id) {
    fbb_.AddOffset(NYCBusStopUpdate::VT_STOP_ID, stop_id);
  }
  void add_stop_departing_on(int32_t stop_departing_on) {
    fbb_.AddElement<int32_t>(NYCBusStopUpdate::VT_STOP_DEPARTING_ON, stop_departing_on, 0);
  }
  void add_position(flatbuffers::Offset<Position> position) {
    fbb_.AddOffset(NYCBusStopUpdate::VT_POSITION, position);
  }
  void add_delay(int32_t delay) {
    fbb_.AddElement<int32_t>(NYCBusStopUpdate::VT_DELAY, delay, 0);
  }
  explicit NYCBusStopUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NYCBusStopUpdateBuilder &operator=(const NYCBusStopUpdateBuilder &);
  flatbuffers::Offset<NYCBusStopUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NYCBusStopUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<NYCBusStopUpdate> CreateNYCBusStopUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    flatbuffers::Offset<NYCBusTrip> trip = 0,
    TripStatus current_status = TripStatus_AtStation,
    flatbuffers::Offset<flatbuffers::String> stop_id = 0,
    int32_t stop_departing_on = 0,
    flatbuffers::Offset<Position> position = 0,
    int32_t delay = 0) {
  NYCBusStopUpdateBuilder builder_(_fbb);
  builder_.add_delay(delay);
  builder_.add_position(position);
  builder_.add_stop_departing_on(stop_departing_on);
  builder_.add_stop_id(stop_id);
  builder_.add_trip(trip);
  builder_.add_timestamp(timestamp);
  builder_.add_current_status(current_status);
  return builder_.Finish();
}

inline flatbuffers::Offset<NYCBusStopUpdate> CreateNYCBusStopUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    flatbuffers::Offset<NYCBusTrip> trip = 0,
    TripStatus current_status = TripStatus_AtStation,
    const char *stop_id = nullptr,
    int32_t stop_departing_on = 0,
    flatbuffers::Offset<Position> position = 0,
    int32_t delay = 0) {
  return nyc::realtime::CreateNYCBusStopUpdate(
      _fbb,
      timestamp,
      trip,
      current_status,
      stop_id ? _fbb.CreateString(stop_id) : 0,
      stop_departing_on,
      position,
      delay);
}

struct NYCBusScheduleUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_TRIP = 6,
    VT_SCHEDULE = 8,
    VT_CURRENT_STOP_ID = 10
  };
  int32_t timestamp() const {
    return GetField<int32_t>(VT_TIMESTAMP, 0);
  }
  const NYCBusTrip *trip() const {
    return GetPointer<const NYCBusTrip *>(VT_TRIP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NYCBusSchedule>> *schedule() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NYCBusSchedule>> *>(VT_SCHEDULE);
  }
  const flatbuffers::String *current_stop_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CURRENT_STOP_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_TRIP) &&
           verifier.VerifyTable(trip()) &&
           VerifyOffset(verifier, VT_SCHEDULE) &&
           verifier.Verify(schedule()) &&
           verifier.VerifyVectorOfTables(schedule()) &&
           VerifyOffset(verifier, VT_CURRENT_STOP_ID) &&
           verifier.Verify(current_stop_id()) &&
           verifier.EndTable();
  }
};

struct NYCBusScheduleUpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int32_t timestamp) {
    fbb_.AddElement<int32_t>(NYCBusScheduleUpdate::VT_TIMESTAMP, timestamp, 0);
  }
  void add_trip(flatbuffers::Offset<NYCBusTrip> trip) {
    fbb_.AddOffset(NYCBusScheduleUpdate::VT_TRIP, trip);
  }
  void add_schedule(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NYCBusSchedule>>> schedule) {
    fbb_.AddOffset(NYCBusScheduleUpdate::VT_SCHEDULE, schedule);
  }
  void add_current_stop_id(flatbuffers::Offset<flatbuffers::String> current_stop_id) {
    fbb_.AddOffset(NYCBusScheduleUpdate::VT_CURRENT_STOP_ID, current_stop_id);
  }
  explicit NYCBusScheduleUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NYCBusScheduleUpdateBuilder &operator=(const NYCBusScheduleUpdateBuilder &);
  flatbuffers::Offset<NYCBusScheduleUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NYCBusScheduleUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<NYCBusScheduleUpdate> CreateNYCBusScheduleUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    flatbuffers::Offset<NYCBusTrip> trip = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NYCBusSchedule>>> schedule = 0,
    flatbuffers::Offset<flatbuffers::String> current_stop_id = 0) {
  NYCBusScheduleUpdateBuilder builder_(_fbb);
  builder_.add_current_stop_id(current_stop_id);
  builder_.add_schedule(schedule);
  builder_.add_trip(trip);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<NYCBusScheduleUpdate> CreateNYCBusScheduleUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    flatbuffers::Offset<NYCBusTrip> trip = 0,
    const std::vector<flatbuffers::Offset<NYCBusSchedule>> *schedule = nullptr,
    const char *current_stop_id = nullptr) {
  return nyc::realtime::CreateNYCBusScheduleUpdate(
      _fbb,
      timestamp,
      trip,
      schedule ? _fbb.CreateVector<flatbuffers::Offset<NYCBusSchedule>>(*schedule) : 0,
      current_stop_id ? _fbb.CreateString(current_stop_id) : 0);
}

struct NYCBusTrips FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_TRIPS = 6
  };
  int32_t timestamp() const {
    return GetField<int32_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NYCBusScheduleUpdate>> *trips() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NYCBusScheduleUpdate>> *>(VT_TRIPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_TRIPS) &&
           verifier.Verify(trips()) &&
           verifier.VerifyVectorOfTables(trips()) &&
           verifier.EndTable();
  }
};

struct NYCBusTripsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int32_t timestamp) {
    fbb_.AddElement<int32_t>(NYCBusTrips::VT_TIMESTAMP, timestamp, 0);
  }
  void add_trips(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NYCBusScheduleUpdate>>> trips) {
    fbb_.AddOffset(NYCBusTrips::VT_TRIPS, trips);
  }
  explicit NYCBusTripsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NYCBusTripsBuilder &operator=(const NYCBusTripsBuilder &);
  flatbuffers::Offset<NYCBusTrips> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NYCBusTrips>(end);
    return o;
  }
};

inline flatbuffers::Offset<NYCBusTrips> CreateNYCBusTrips(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NYCBusScheduleUpdate>>> trips = 0) {
  NYCBusTripsBuilder builder_(_fbb);
  builder_.add_trips(trips);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<NYCBusTrips> CreateNYCBusTripsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    const std::vector<flatbuffers::Offset<NYCBusScheduleUpdate>> *trips = nullptr) {
  return nyc::realtime::CreateNYCBusTrips(
      _fbb,
      timestamp,
      trips ? _fbb.CreateVector<flatbuffers::Offset<NYCBusScheduleUpdate>>(*trips) : 0);
}

struct NYCBusTripComplete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIMESTAMP = 4,
    VT_VEHICLE_ID = 6
  };
  int32_t timestamp() const {
    return GetField<int32_t>(VT_TIMESTAMP, 0);
  }
  const flatbuffers::String *vehicle_id() const {
    return GetPointer<const flatbuffers::String *>(VT_VEHICLE_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TIMESTAMP) &&
           VerifyOffset(verifier, VT_VEHICLE_ID) &&
           verifier.Verify(vehicle_id()) &&
           verifier.EndTable();
  }
};

struct NYCBusTripCompleteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(int32_t timestamp) {
    fbb_.AddElement<int32_t>(NYCBusTripComplete::VT_TIMESTAMP, timestamp, 0);
  }
  void add_vehicle_id(flatbuffers::Offset<flatbuffers::String> vehicle_id) {
    fbb_.AddOffset(NYCBusTripComplete::VT_VEHICLE_ID, vehicle_id);
  }
  explicit NYCBusTripCompleteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NYCBusTripCompleteBuilder &operator=(const NYCBusTripCompleteBuilder &);
  flatbuffers::Offset<NYCBusTripComplete> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NYCBusTripComplete>(end);
    return o;
  }
};

inline flatbuffers::Offset<NYCBusTripComplete> CreateNYCBusTripComplete(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    flatbuffers::Offset<flatbuffers::String> vehicle_id = 0) {
  NYCBusTripCompleteBuilder builder_(_fbb);
  builder_.add_vehicle_id(vehicle_id);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<NYCBusTripComplete> CreateNYCBusTripCompleteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t timestamp = 0,
    const char *vehicle_id = nullptr) {
  return nyc::realtime::CreateNYCBusTripComplete(
      _fbb,
      timestamp,
      vehicle_id ? _fbb.CreateString(vehicle_id) : 0);
}

}  // namespace realtime
}  // namespace nyc

#endif  // FLATBUFFERS_GENERATED_RTNYCPROTOCOL_NYC_REALTIME_H_
